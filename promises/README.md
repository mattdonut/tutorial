# Promises

## Timing

The whole point of Promises is timing, but to get an handle on how they will interact with your code we have to look at how code JavaScript code is executed. Its a little tricky, because the runtime behavior isn't really captured in the language itself, you just have to know it.

### The Event Loop

The Event Loop is the main execution method in Javascript. This is actually a bit of a misnomer for our purposes, because it's really a Task loop. Events are generated by the engine (when the clicks something, or a file finishes reading), and if a handler is registered then a Task is placed in the queue to run the Javascript with any associated arguments. There are a few other ways that a Task gets added to the queue, such as the engine starting a Javascript program, or a setTimeout callback.

For example, if you call `setTimeout(doSomething, 100)`, this will cause the engine to wait 100ms and then place a Task onto the queue to call the function `doSomething`. (Side note: this is why you can not count on `doSomething` to be called exactly 100ms later: the queue might take a while to get to it)

Tasks are always run to completion in a single thread, and no other Javascript will run (at least, not in this interpreter instance) at the same time.

The Event Loop actually batches Tasks on each "loop". It will drain the queue, execute all of those tasks to completion, potentialy do other stuff not related to Javascript (like redrawing the screen in a browser), then loop back and look for more Tasks.

This means that if you create new Tasks from within a Task (say, `setTimeout(doSomething, 0)`), it _will not_ be executed on the current loop, and in fact you have no idea how long it will be or what might happen in the meantime

### TL:DR;

The Event Loop flushes the Task queue, does all the tasks to completion in order, does whatever it wants for a bit, then loops around and waits for new Tasks. Tasks might have arrived by then, at which point it runs the queue imediately.

## But wait, there's More! Microtasks!

We haven't talked about Microtasks! There is a secondary queue in addition to the Task queue, which is run after **each** task. The main other differrence between this queue and the Task queue is that the Microtask queue checks the full queue after each Microtask is executed. This means that if you add a new Microtask from within a Microtask, it _will_ be executed in this loop. This is why they want these to be _micro_, they run _all_ of them before anything else gets to happen, so you can totally hose your system if you do to much.

### TL:DR;

Turns out the Event Loop is actually:

Get all Tasks -> Run First Task -> Run ALL Microtasks -> Run Second Task -> Run ALL MicroTasks -> ... -> Run Last Task -> Run ALL Microtasks -> Engine Does Whatever it Wants (goes for coffee, on the moon...) -> Next Loop, check for Tasks...

## What does this have to do with me?

You came here for Promises, and we've barely even mentioned them!

So, a Promise is an object that represents work that has been started somewhere, and eventally the result of that work. Promises have internal state (you may have seen some of this if you've logged one directly), which you should never directly interact with in code, but is good to think about mentally.

A Promise is either `pending` or `settled`, which represents whether the work do be done is finished or not. Once the Promise is `settled`, it will contain the result of the work. This result will either be a value, or an error. The question we are concerned with here is: How do we get notified when the work is done?

The answer, is Microtasks!

When a Promise settles, it will create a new Microtask to call the appropriete handlers with the result.

> If you roll your own Promise with the `new Promise((resolve, reject) => {})`, when you call either `resolve` or `reject` these special functions do the enqueing of the Microtask

Next question: Where do these handlers come from?

## `.then()`!

`.then()` adds handlers to the Promise it is called on, with the first argument as the value handler, and the second argument as the error handler. It actually also does several other things. It will check to see if the Promise is already settled, and if it is, it will **enqueue a new Microtask to call the new handler with the result**. This is very important: **It will not call the handler directly, ever.**

The other thing `.then()` will do is create and return a new Promise that "follows" the previous Promise. The new Promise will yeild the return values from the handler functions used to create it, once the originating promise has settled. If either handler is omitted from the `.then()` call (which is allowed and often expected), the new Promise will just yield the result from the original Promise in the channels that are omitted.

## TL:DR;

`.then()` adds handlers to the attached promise, and _might_ enqueue a MicroTask to call those handlers with the result. It will **never** call that handler directly.

## Promises All the Way Down

When you use `.then()` to add handlers to a Promise, you also get a new Promise that acts as a `map` of the original Promise's result. While this is certainly handy, there is one additional feature that makes it very powerful. If you return a _Promise_ from your handler, the new Promise made by `.then()` will automatically follow _that_ promise instead! This allows you to chain together asynchronous work that depends on a prior result, and synchronously have a handle that will allow access to the result.

> Suppose we have an API for dealing with users, which can get user info using an ID, and has an endpoint for getting our Current UserID. We can use code like:
>
> ```
> const finalResultPromise = apiGetCurrentUserID().then(id => {
>   return apiGetUserInfo(id)
> })
> ```
>
> `finalResultPromise` will be a Promise that will eventually yield our current user's Info! Notice that we have access to this _Promise_ immediately, but not its value. We have to ask it nicely if we want that
>
> ```
> finalResultPromise.then(userInfo => ...)
> ```

## Timing, again

So when do these handlers all run?

Since they use Microtasks to execute, they _always_ run _after_ a step in the main Task queue. All newly settled Promises or newly added handlers of previously settled promises will run in the same Microtask queue flush, including any new settled Promises that arise as a result of those handlers (say by returning a settled promise from a handler). This means that all Promises will do as much as they can before the engine does anything outside of JavaScript.

# TL:DR;

All Promises that can do work do so _after_ every main Task, but always before the next Task.

This really sums it all up.
